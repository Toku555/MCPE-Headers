#pragma once
namespace j{
	class mce{
		public:
		void getAlignedOffset(uint,uint);
		void bindBlendState(mce::RenderContext &);
		void operator==(mce::BlendStateDescription const&);
		void bindBlendState(mce::RenderContext &,bool);
		void createBlendState(mce::RenderContext &,mce::BlendStateDescription const&);
		void releaseBuffer(void);
		void getInternalBufferSize(void);
		void releaseBuffer(void);
		void updateBuffer(mce::RenderContext &,uint,void const*,uint);
		void BufferOGL(mce::BufferOGL&&);
		void BufferOGL(void);
		void bindBuffer(mce::RenderContext &);
		void isValid(void);
		void recreateBuffer(mce::RenderContext &,uint,void const*,uint);
		void releaseBuffer(void);
		void ~BufferOGL();
		void sync(mce::RenderContext &);
		void sync(mce::RenderContext &);
		void ConstantBufferContainerBase(mce::ConstantBufferContainerBase&&);
		void ConstantBufferContainerBase(void);
		void allocateRenderContextBuffer(mce::RenderContext &);
		void bindConstantBuffer(mce::RenderContext &,uint,uint);
		void finalizeConstantBufferLayout(void);
		void getConstantBufferName(void);
		void getConstantBufferSize(void);
		void isDirty(void);
		void registerReflectedShaderParameter(mce::UniformMetaData const&);
		void ~ConstantBufferContainerBase();
		void ConstantBufferContainerOGL(mce::ConstantBufferContainerOGL&&);
		void ConstantBufferContainerOGL(void);
		void sync(mce::RenderContext &);
		void ~ConstantBufferContainerOGL();
		void bindDepthStencilState(mce::RenderContext &);
		void operator==(mce::DepthStencilStateDescription const&);
		void bindDepthStencilState(mce::RenderContext &,bool);
		void createDepthState(mce::RenderContext &,mce::DepthStencilStateDescription const&);
		void DeviceInformationBase(void);
		void getChipsetName(void);
		void getChipsetVendorName(void);
		void getGraphicsExtensions(void);
		void getNativeScreenHeight(void);
		void getNativeScreenWidth(void);
		void DeviceInformationOGL(void);
		void findChipsetInfo(void);
		void checkFeatureSupport(mce::RenderFeature);
		void getMaxVertexCount(void);
		void bindFrameBufferAttachment(void);
		void getFrameBufferAttachmentDescription(void);
		void ~FrameBufferAttachmentBase();
		void FrameBufferAttachmentOGL(mce::FrameBufferAttachmentOGL&&);
		void FrameBufferAttachmentOGL(void);
		void createFrameBufferAttachment(mce::RenderContext &);
		void createFrameBufferAttachment(mce::RenderContext &,mce::Texture &&,uchar);
		void ~FrameBufferAttachmentOGL();
		void clearDepthStencilBuffer(void);
		void clearDepthStencilBuffer(void);
		void clearFrameBuffer(Color const&);
		void clearStencilBuffer(void);
		void clearDepthStencilBuffer(float,float);
		void clearFrameBuffer(Color const&);
		void createFrameBufferAttachment(mce::RenderContext &,mce::FrameBufferAttachmentDescription const&);
		void ~FrameBufferObjectBase();
		void FrameBufferObjectOGL(mce::FrameBufferObjectOGL&&);
		void FrameBufferObjectOGL(void);
		void bindFrameBuffer(void);
		void clearDepthStencilBuffer(float,float);
		void clearFrameBuffer(Color const&);
		void clearStencilBuffer(void);
		void createFrameBuffer(mce::RenderContext &,mce::FrameBufferDescription const&);
		void createFrameBufferAttachment(mce::RenderContext &,mce::FrameBufferAttachmentDescription const&);
		void finalizeFrameBuffer(void);
		void resolveFrameBuffer(mce::FrameBufferObject const&);
		void resolveFrameBuffer(void);
		void setResolveSource(mce::RenderContext &,mce::FrameBufferObject const&);
		void ~FrameBufferObjectOGL();
		void init(void);
		void releaseBuffer(void);
		void ImmediateBufferOGL(void);
		void updateBuffer(mce::RenderContext &,uint,void *&,uint);
		void ~MaterialPtr();
		void render(mce::MaterialPtr const&,uint,uint);
		void reset(void);
		void reset(void);
		void ~Mesh();
		void getGlobalQuadBuffer(mce::RenderContext &,uint);
		void bindRasterizerState(mce::RenderContext &);
		void operator==(mce::RasterizerStateDescription const&);
		void ~RasterizerStateDescription();
		void bindRasterizerState(mce::RenderContext &,bool);
		void createRasterizerStateDescription(mce::RenderContext &,mce::RasterizerStateDescription const&);
		void setScissorRect(mce::RenderContext &,float,float,float,float);
		void clearDepthStencilBuffer(void);
		void endFrame(void);
		void setRenderTarget(void);
		void clearContextState(void);
		void createWindowSizeDependentResources(void);
		void getDevice(void);
		void lostContext(void);
		void setRenderTarget(void);
		void unbindAllTextures(void);
		void ~RenderContextBase();
		void captureScreenAsRGB(std::string &,int &,int &);
		void clearDepthStencilBuffer(void);
		void clearFrameBuffer(Color const&);
		void clearStencilBuffer(void);
		void discardBackbuffer(void);
		void draw(mce::PrimitiveMode,uint,uint);
		void drawIndexed(mce::PrimitiveMode,uint);
		void drawIndexed(mce::PrimitiveMode,uint,uint);
		void flush(void);
		void lostContext(void);
		void setDepthRange(float,float);
		void setRenderTarget(void);
		void setViewport(uint,uint,float,float);
		void swapBuffers(void);
		void unbindAllTextures(void);
		void ~RenderContextOGL();
		void removeIfBound(mce::TextureBase const&);
		void getMultisampleQualityLevels(mce::TextureFormat,std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void getRenderContext(void);
		void getRenderContextAsConst(void);
		void createDevice(mce::RenderContext &);
		void deviceWasLostOnPresent(void);
		void getRenderContext(void);
		void getRenderContextAsConst(void);
		void lostDevice(void);
		void checkFeatureSupport(mce::RenderFeature);
		void createDevice(mce::RenderContext &);
		void getMaxVertexCount(void);
		void getMultisampleQualityLevels(mce::TextureFormat,std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void ~RenderDeviceOGL();
		void addScreenToRenderGraph(std::shared_ptr<AbstractScreen> &);
		void clearRenderGraph(void);
		void postRender(RenderGraphContext &);
		void postRender(RenderGraphContext &);
		void preRender(RenderGraphContext &);
		void bindSamplerState(mce::RenderContext &);
		void SamplerStateDescription(void);
		void bindSamplerState(mce::RenderContext &,bool);
		void createSamplerState(mce::RenderContext &,mce::SamplerStateDescription const&,ushort);
		void compileAndLinkShader(void);
		void isBuiltFrom(std::string const&,std::string const&,std::string const&,std::string const&);
		void syncUniform(int);
		void setShaderColors(void);
		void ShaderOGL(mce::ShaderProgram &,mce::ShaderProgram &,mce::ShaderProgram &);
		void bindShader(mce::RenderContext &,mce::VertexFormat const&,void *,uint);
		void compileAndLinkShader(void);
		void finalizeShaderUniforms(void);
		void freeCompilerResources(void);
		void refelectShaderAttributes(void);
		void resetLastProgram(void);
		void ~ShaderOGL();
		void sizeInBytesFromShaderPrimitiveType(mce::ShaderPrimitiveTypes);
		void ShaderProgramOGL(mce::ShaderType,std::string const&,std::string const&,std::string const&);
		void ~ShaderProgramOGL();
		void createSwapChain(mce::RenderDevice &,mce::SwapChainDescription const&);
		void getMultisampleQualityLevels(std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void isMultisampledSwapChain(void);
		void createSwapChain(mce::RenderDevice &,mce::SwapChainDescription const&);
		void present(void);
		void releaseSwapChain(void);
		void resizeBuffers(mce::RenderDevice &,uint,uint);
		void deleteTexture(void);
		void bindTexture(mce::RenderContext &,uint,uint);
		void deleteTexture(void);
		void getDescription(void);
		void isCreated(void);
		void ownsResource(void);
		void unbindTexture(mce::RenderContext &,uint);
		void ~TextureBase();
		void removeTickingTextures(void);
		void TextureOGL(uint);
		void TextureOGL(void);
		void bindTexture(mce::RenderContext &,uint,uint);
		void copyTexture(mce::RenderContext &,mce::Texture *,uint,uint,uint,uint);
		void createTexture(mce::RenderContext &,mce::TextureDescription const&);
		void deleteTexture(void);
		void getInternalTexture(void);
		void lock(mce::RenderContext &);
		void subBuffer(mce::RenderContext &,void const*);
		void subBuffer(mce::RenderContext &,void const*,uint,uint,uint,uint,uint);
		void unbindTexture(mce::RenderContext &,uint);
		void unlock(mce::RenderContext &);
		void ~TextureOGL();
		void _move(mce::TexturePtr&&);
		void enableField(mce::VertexField);
		void resetViewProjOverride(void);
		void setMatrixPatch(Matrix const&);
	}
};
