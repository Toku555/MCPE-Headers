#pragma once
namespace mce{
	class AlignmentHelper{
		public:
		void getAlignedOffset(uint,uint);
		void Attribute(uint,uint,mce::VertexField);
		void Attribute(void);
		void getLocation(void);
		void getVertexField(void);
		void operator==(mce::Attribute const&);
		void bindBlendState(mce::RenderContext &);
		void createBlendState(mce::RenderContext &,mce::BlendStateDescription const&);
		void bindBlendState(mce::RenderContext &);
		void createBlendState(mce::RenderContext &,mce::BlendStateDescription const&);
		void BlendStateDescription(void);
		void operator!=(mce::BlendStateDescription const&);
		void operator==(mce::BlendStateDescription const&);
		void bindBlendState(mce::RenderContext &,bool);
		void createBlendState(mce::RenderContext &,mce::BlendStateDescription const&);
		void Buffer(mce::Buffer&&);
		void Buffer(void);
		void bindBuffer(mce::RenderContext &);
		void createBuffer(mce::RenderContext &,uint,void const*,uint,mce::BufferType);
		void createDynamicBuffer(mce::RenderContext &,uint,mce::BufferType,void const*);
		void createDynamicIndexBuffer(mce::RenderContext &,uint);
		void createDynamicVertexBuffer(mce::RenderContext &,uint);
		void createIndexBuffer(mce::RenderContext &,uint,void const*,uint);
		void createVertexBuffer(mce::RenderContext &,uint,void const*,uint);
		void getInternalBufferSize(void);
		void isValid(void);
		void operator=(mce::Buffer&&);
		void releaseBuffer(void);
		void resizeBuffer(mce::RenderContext &,void const*,uint);
		void updateBuffer(mce::RenderContext &,uint,void const*,uint);
		void ~Buffer();
		void BufferBase(mce::BufferBase&&);
		void BufferBase(void);
		void createBuffer(mce::RenderContext &,uint,void const*,uint,mce::BufferType);
		void createDynamicBuffer(mce::RenderContext &,uint,mce::BufferType,void const*);
		void getInternalBufferSize(void);
		void operator=(mce::BufferBase&&);
		void releaseBuffer(void);
		void updateBuffer(mce::RenderContext &,uint,void const*,uint);
		void ~BufferBase();
		void BufferCache(uint,mce::BufferType);
		void clear(void);
		void findBestFit(mce::RenderContext &,uint);
		void get(mce::RenderContext &,uint,uint,void const*,char const*);
		void getStats(void);
		void onAppResumed(void);
		void release(mce::RenderContext &,mce::Buffer &);
		void trim(void);
		void ~BufferCache();
		void ~BufferCache();
		void BufferOGL(mce::BufferOGL&&);
		void BufferOGL(void);
		void createBuffer(mce::RenderContext &,uint,void const*,uint,mce::BufferType);
		void createBuffer(mce::RenderContext &,uint,void const*,uint,mce::BufferType,bool);
		void createDynamicBuffer(mce::RenderContext &,uint,mce::BufferType,void const*);
		void isValid(void);
		void operator=(mce::BufferOGL&&);
		void releaseBuffer(void);
		void resizeBuffer(mce::RenderContext &,void const*,uint);
		void updateBuffer(mce::RenderContext &,uint,void const*,uint,mce::MapType);
		void ~BufferOGL();
		void getInternalMemory(void);
		void ConstantBufferContainer(mce::ConstantBufferContainer&&);
		void ConstantBufferContainer(void);
		void allocateRenderContextBuffer(mce::RenderContext &);
		void bindConstantBuffer(mce::RenderContext &,uint,uint);
		void finalizeConstantBufferLayout(void);
		void getConstantBufferName(void);
		void getConstantBufferSize(void);
		void getUnspecializedShaderConstant(std::string const&);
		void isDirty(void);
		void registerReflectedShaderParameter(mce::UniformMetaData const&);
		void sync(mce::RenderContext &);
		void ~ConstantBufferContainer();
		void ConstantBufferContainerBase(mce::ConstantBufferContainerBase&&);
		void ConstantBufferContainerBase(void);
		void allocateRenderContextBuffer(mce::RenderContext &);
		void bindConstantBuffer(mce::RenderContext &,uint,uint);
		void finalizeConstantBufferLayout(void);
		void getConstantBufferName(void);
		void getConstantBufferSize(void);
		void isDirty(void);
		void ShaderConstantFloat1>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantFloat2>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantFloat3>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantFloat4>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantInt1>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantInt2>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantInt3>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantInt4>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantMatrix2x2>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantMatrix3x3>(mce::ShaderConstantBase const&,void *);
		void ShaderConstantMatrix4x4>(mce::ShaderConstantBase const&,void *);
		void registerReflectedShaderParameter(mce::UniformMetaData const&);
		void registerShaderParameter(mce::ShaderConstantBase const&);
		void sync(mce::RenderContext &);
		void ~ConstantBufferContainerBase();
		void ConstantBufferContainerOGL(mce::ConstantBufferContainerOGL&&);
		void ConstantBufferContainerOGL(void);
		void sync(mce::RenderContext &);
		void ~ConstantBufferContainerOGL();
		void ConstantBufferMetaData(void);
		void getConstantBufferName(void);
		void getRequiredSpaceForUniforms(void);
		void getUniformMetaDataByIndex(uint);
		void getUniformMetaDataByName(std::string const&);
		void ~ConstantBufferMetaData();
		void ConstantBufferMetaDataManager(void);
		void allocateConstantBufferContainers(mce::GlobalConstantBufferManager &);
		void findConstantBuffer(std::string const&);
		void findUniformMetaData(std::string const&);
		void ~ConstantBufferMetaDataManager();
		void bindDepthStencilState(mce::RenderContext &);
		void createDepthState(mce::RenderContext &,mce::DepthStencilStateDescription const&);
		void bindDepthStencilState(mce::RenderContext &);
		void createDepthState(mce::RenderContext &,mce::DepthStencilStateDescription const&);
		void setStencilRef(mce::RenderContext &);
		void DepthStencilStateDescription(void);
		void operator!=(mce::DepthStencilStateDescription const&);
		void operator==(mce::DepthStencilStateDescription const&);
		void DepthStencilStateOGL(void);
		void bindDepthStencilState(mce::RenderContext &,bool);
		void createDepthState(mce::RenderContext &,mce::DepthStencilStateDescription const&);
		void DeviceInformation(void);
		void findChipsetInfo(void);
		void getChipsetName(void);
		void getChipsetVendorName(void);
		void getGraphicsExtensions(void);
		void getNativeScreenHeight(void);
		void getNativeScreenWidth(void);
		void DeviceInformationBase(void);
		void findChipsetInfo(void);
		void getChipsetName(void);
		void getChipsetVendorName(void);
		void getGraphicsExtensions(void);
		void getGraphicsVersion(void);
		void getNativeScreenHeight(void);
		void getNativeScreenWidth(void);
		void DeviceInformationOGL(void);
		void findChipsetInfo(void);
		void EnableScissorTest(bool);
		void EnableScissorTest(int,int,int,int);
		void ~EnableScissorTest();
		void EntityConstants(void);
		void init(void);
		void checkForErrors(std::string);
		void FrameBufferAttachment(mce::FrameBufferAttachment&&);
		void FrameBufferAttachment(void);
		void allocateFrameBufferAttachment(void);
		void bindFrameBufferAttachment(void);
		void createFrameBufferAttachment(void);
		void ~FrameBufferAttachment();
		void FrameBufferAttachmentBase(mce::FrameBufferAttachmentBase&&);
		void FrameBufferAttachmentBase(void);
		void allocateFrameBufferAttachment(void);
		void bindFrameBufferAttachment(void);
		void createFrameBufferAttachment(void);
		void getFrameBufferAttachmentDescription(void);
		void ~FrameBufferAttachmentBase();
		void FrameBufferAttachmentDescription(uint,uint);
		void FrameBufferAttachmentDescription(void);
		void setTextureFormatAndAttachmentType(mce::TextureFormat);
		void FrameBufferAttachmentOGL(mce::FrameBufferAttachmentOGL&&);
		void FrameBufferAttachmentOGL(void);
		void allocateFrameBufferAttachment(void);
		void allocateRenderBuffer(void);
		void bindRenderBuffer(void);
		void checkBinding(void);
		void createFrameBufferAttachment(void);
		void createRenderBuffer(void);
		void destroyFrameBufferAttachment(void);
		void destroyRenderBuffer(void);
		void setBackingTexture(uint);
		void setResolveTexture(uint);
		void ~FrameBufferAttachmentOGL();
		void FrameBufferDescription(void);
		void FrameBufferObject(mce::FrameBufferObject&&);
		void FrameBufferObject(void);
		void bindFrameBuffer(void);
		void clearFrameBuffer(void);
		void createFrameBuffer(mce::RenderContext &,mce::FrameBufferDescription const&);
		void createFrameBufferAttachment(mce::RenderContext &,mce::FrameBufferAttachmentDescription const&);
		void finalizeFrameBuffer(void);
		void resolveFrameBuffer(mce::FrameBufferObject const&);
		void resolveFrameBuffer(void);
		void setResolveSource(mce::RenderContext &,mce::FrameBufferObject const&);
		void ~FrameBufferObject();
		void FrameBufferObjectBase(mce::FrameBufferObjectBase&&);
		void FrameBufferObjectBase(void);
		void advanceFrame(void);
		void bindFrameBuffer(void);
		void clearFrameBuffer(void);
		void createFrameBuffer(mce::RenderContext &,mce::FrameBufferDescription const&);
		void createFrameBufferAttachment(mce::RenderContext &,mce::FrameBufferAttachmentDescription const&);
		void finalizeFrameBuffer(void);
		void getFrameBufferDescription(void);
		void resolveFrameBuffer(mce::FrameBufferObject const&);
		void resolveFrameBuffer(void);
		void setResolveSource(mce::RenderContext &,mce::FrameBufferObject const&);
		void ~FrameBufferObjectBase();
		void FrameBufferObjectOGL(mce::FrameBufferObjectOGL&&);
		void FrameBufferObjectOGL(void);
		void bindFrameBuffer(void);
		void clearFrameBuffer(void);
		void createFrameBuffer(mce::RenderContext &,mce::FrameBufferDescription const&);
		void createFrameBufferAttachment(mce::RenderContext &,mce::FrameBufferAttachmentDescription const&);
		void destroyFrameBuffer(void);
		void finalizeFrameBuffer(void);
		void isBound(void);
		void resolveFrameBuffer(mce::FrameBufferObject const&);
		void resolveFrameBuffer(void);
		void setAttachmentIndexAndClearMask(mce::FrameBufferAttachment &);
		void ~FrameBufferObjectOGL();
		void GlobalConstantBufferManager(void);
		void allocateAndSetupConstantBuffersFromMetadata(mce::RenderContext &);
		void findConstantBufferContainer(std::string const&);
		void refreshWorldConstants(void);
		void ~GlobalConstantBufferManager();
		void init(void);
		void HoloConstants(void);
		void init(void);
		void ImageDescription(void);
		void getSizeInBytes(void);
		void ImmediateBuffer(void);
		void createDynamicBuffer(mce::RenderContext &,uint,mce::BufferType,void const*);
		void isValid(void);
		void releaseBuffer(void);
		void updateBuffer(mce::RenderContext &,uint,void *&,uint);
		void ImmediateBufferOGL(void);
		void createDynamicBuffer(mce::RenderContext &,uint,mce::BufferType,void const*);
		void MaterialPtr(mce::MaterialPtr&&);
		void MaterialPtr(mce::RenderMaterialGroup &,std::string const&);
		void MaterialPtr(void);
		void _deref(void);
		void _move(mce::MaterialPtr&&);
		void onGroupReloaded(void);
		void operator=(mce::MaterialPtr&&);
		void ~MaterialPtr();
		void interpolateTransforms(glm::detail::tmat4x4<float> &,glm::detail::tmat4x4<float> const&,glm::detail::tmat4x4<float> const&,float);
		void Mesh(mce::Mesh&&);
		void Mesh(mce::VertexFormat const&,uint,uint,uchar,mce::PrimitiveMode,uchar *,bool);
		void Mesh(void);
		void _move(mce::Mesh&);
		void clearGlobalBuffers(void);
		void isTemporary(void);
		void isValid(void);
		void loadIndexBuffer(uint,void const*,uint);
		void loadRawData(mce::RenderContext &,uchar *);
		void operator=(mce::Mesh&&);
		void releaseIndexBuffer(void);
		void render(mce::MaterialPtr const&,mce::TexturePtr const&,mce::TexturePtr const&,mce::TexturePtr const&,uint,uint);
		void render(mce::MaterialPtr const&,mce::TexturePtr const&,mce::TexturePtr const&,uint,uint);
		void render(mce::MaterialPtr const&,mce::TexturePtr const&,uint,uint);
		void render(mce::MaterialPtr const&,uint,uint);
		void reset(void);
		void ~Mesh();
		void PerFrameConstants(void);
		void init(void);
		void ProfileSection(char const*);
		void ~ProfileSection();
		void beginProfileSection(char const*);
		void endProfileEvent(void);
		void destroyInstance(void);
		void getGlobalQuadBuffer(mce::RenderContext &,uint,uchar &);
		void getInstance(mce::RenderContext &,uint,uchar &);
		void onAppSuspended(void);
		void onAppTerminated(void);
		void ~QuadIndexBuffer();
		void ~QuadIndexBuffer();
		void RasterizerState(void);
		void bindRasterizerState(mce::RenderContext &);
		void createRasterizerStateDescription(mce::RenderContext &,mce::RasterizerStateDescription const&);
		void setScissorRect(mce::RenderContext &,int,int,int,int);
		void ~RasterizerState();
		void bindRasterizerState(mce::RenderContext &);
		void createRasterizerStateDescription(mce::RenderContext &,mce::RasterizerStateDescription const&);
		void RasterizerStateDescription(void);
		void operator!=(mce::RasterizerStateDescription const&);
		void operator==(mce::RasterizerStateDescription const&);
		void ~RasterizerStateDescription();
		void bindRasterizerState(mce::RenderContext &,bool);
		void createRasterizerStateDescription(mce::RenderContext &,mce::RasterizerStateDescription const&);
		void setScissorRect(mce::RenderContext &,int,int,int,int);
		void RenderChunkConstants(void);
		void init(void);
		void RenderContext(void);
		void captureScreenAsRGB(std::string &,int &,int &);
		void clearContextState(void);
		void clearDepthStencilBuffer(void);
		void clearFrameBuffer(Color const&);
		void clearStencilBuffer(void);
		void createWindowSizeDependentResources(void);
		void discardBackbuffer(void);
		void draw(mce::PrimitiveMode,uint,uint);
		void drawIndexed(mce::PrimitiveMode,uint,uchar);
		void drawIndexed(mce::PrimitiveMode,uint,uint,uchar);
		void getMaxVertexCount(void);
		void lostContext(void);
		void setDepthRange(float,float);
		void setRenderTarget(void);
		void setViewport(uint,uint,float,float);
		void swapBuffers(void);
		void ~RenderContext();
		void RenderContextBase(void);
		void clearContextState(void);
		void createWindowSizeDependentResources(void);
		void getDevice(void);
		void getStencilReferenceFromParameter(uchar);
		void getStencilReferenceFromRenderContext(void);
		void isHolographicMode(void);
		void isStereoEnabled(void);
		void lostContext(void);
		void setHolographicMode(bool);
		void setStencilReference(uchar);
		void ~RenderContextBase();
		void get(void);
		void getAsConst(void);
		void RenderContextOGL(void);
		void captureScreenAsRGB(std::string &,int &,int &);
		void clearContextState(void);
		void clearDepthStencilBuffer(void);
		void clearFrameBuffer(Color const&);
		void clearStencilBuffer(void);
		void discardBackbuffer(void);
		void draw(mce::PrimitiveMode,uint,uint);
		void drawIndexed(mce::PrimitiveMode,uint,uchar);
		void drawIndexed(mce::PrimitiveMode,uint,uint,uchar);
		void getMaxVertexCount(void);
		void lostContext(void);
		void setDepthRange(float,float);
		void setRenderTarget(void);
		void setViewport(uint,uint,float,float);
		void swapBuffers(void);
		void ~RenderContextOGL();
		void RenderContextStateBase(void);
		void RenderDevice(void);
		void createDevice(mce::RenderContext &);
		void deviceWasLostOnPresent(void);
		void getMultisampleQualityLevels(mce::TextureFormat,std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void getRenderContext(void);
		void getRenderContextAsConst(void);
		void lostDevice(void);
		void ~RenderDevice();
		void RenderDeviceBase(void);
		void createDevice(mce::RenderContext &);
		void createRenderContext(void);
		void deviceWasLostOnPresent(void);
		void getDeviceInformation(void);
		void getMultisampleQualityLevels(mce::TextureFormat,std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void getRenderContext(void);
		void getRenderContextAsConst(void);
		void initializeFrameBuffer(mce::SwapChain const&,mce::RenderContext &);
		void lostDevice(void);
		void registerOrGetAttributeListIndex(std::vector<mce::Attribute,std::allocator<mce::Attribute>> const&);
		void ~RenderDeviceBase();
		void createDevice(mce::RenderContext &);
		void RenderMaterial(Json::Value const&,mce::RenderMaterial const&);
		void RenderMaterial(mce::RenderMaterial const&);
		void RenderMaterial(void);
		void SpliceShaderPath(std::string &);
		void _buildHeader(Json::Value const&);
		void _parseStateName(std::string const&);
		void addState(mce::RS);
		void compileShader(void);
		void initContext(void);
		void useWith(mce::RenderContext &,mce::VertexFormat const&,void *);
		void _addRef(mce::MaterialPtr &);
		void _fireGroupDestroyed(void);
		void _fireGroupReloaded(void);
		void _getMaterialOrDefault(std::string const&,mce::RenderMaterial &);
		void _getMaterialPtr(std::string const&);
		void _loadList(void);
		void _material(std::string const&,std::string const&);
		void _removeRef(mce::MaterialPtr &);
		void getMaterial(std::string const&);
		void loadList(std::string const&);
		void onAppResumed(void);
		void onAppSuspended(void);
		void ~RenderMaterialGroup();
		void ~RenderMaterialGroup();
		void RenderStage(void);
		void ~RenderStage();
		void RenderStagePipeline(void);
		void render(mce::RenderContext &);
		void setupRenderStagePipeline(void);
		void shutdownRenderStagePipeline(void);
		void ~RenderStagePipeline();
		void ~RenderStagePipeline();
		void glDeleteBuffersFunc(int,uint *);
		void glGenBuffersFunc(int,uint *);
		void RendererSettings(void);
		void Shader(mce::ShaderProgram &,mce::ShaderProgram &,mce::ShaderProgram &);
		void bindShader(mce::RenderContext &,mce::VertexFormat const&,void *,uint);
		void compileAndLinkShader(void);
		void finalizeShaderUniforms(void);
		void freeCompilerResources(void);
		void isBuiltFrom(std::string const&,std::string const&,std::string const&,std::string const&);
		void resetLastProgram(void);
		void ~Shader();
		void ShaderBase(mce::ShaderProgram &,mce::ShaderProgram &,mce::ShaderProgram &);
		void getAttributeForName(std::string const&,uint);
		void isBuiltFrom(std::string const&,std::string const&,std::string const&,std::string const&);
		void reflectShader(mce::RenderDevice &);
		void validateVertexFormat(mce::VertexFormat const&);
		void ~ShaderBase();
		void ~ShaderConstant();
		void ~ShaderConstant();
		void ShaderConstantBase(void);
		void getConstantSize(void);
		void getElementsExtent(void);
		void getName(void);
		void getPrimitiveSize(void);
		void getType(void);
		void isDirty(void);
		void operator==(mce::ShaderConstantBase const&);
		void ~ShaderConstantBase();
		void ~ShaderConstantBase();
		void syncUniform(int);
		void ~ShaderConstantFloat1();
		void ~ShaderConstantFloat1();
		void syncUniform(int);
		void ~ShaderConstantFloat2();
		void ~ShaderConstantFloat2();
		void syncUniform(int);
		void ~ShaderConstantFloat3();
		void ~ShaderConstantFloat3();
		void syncUniform(int);
		void ~ShaderConstantFloat4();
		void ~ShaderConstantFloat4();
		void syncUniform(int);
		void ~ShaderConstantInt1();
		void ~ShaderConstantInt1();
		void syncUniform(int);
		void ~ShaderConstantInt2();
		void ~ShaderConstantInt2();
		void syncUniform(int);
		void ~ShaderConstantInt3();
		void ~ShaderConstantInt3();
		void syncUniform(int);
		void ~ShaderConstantInt4();
		void ~ShaderConstantInt4();
		void syncUniform(int);
		void ~ShaderConstantMatrix2x2();
		void ~ShaderConstantMatrix2x2();
		void syncUniform(int);
		void ~ShaderConstantMatrix3x3();
		void ~ShaderConstantMatrix3x3();
		void syncUniform(int);
		void ~ShaderConstantMatrix4x4();
		void ~ShaderConstantMatrix4x4();
		void syncUniform(int);
		void ~ShaderConstantOGL();
		void ~ShaderConstantOGL();
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataBase<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstantWithDataOGL<(mce::ShaderPrimitiveTypes);
		void ShaderConstants(void);
		void init(void);
		void setShaderColor(Color const&);
		void setShaderColors(Color const&,Color const&);
		void setShaderDarkenColor(Color const&);
		void getInstance(void);
		void getShaderProgram(mce::ShaderType,std::string const&,std::string const&);
		void loadShader(std::string const&,std::string const&,std::string const&,std::string const&);
		void onAppSuspended(void);
		void ~ShaderGroup();
		void ~ShaderGroup();
		void ShaderOGL(mce::ShaderProgram &,mce::ShaderProgram &,mce::ShaderProgram &);
		void bindVertexPointers(mce::VertexFormat const&,void *);
		void compileAndLinkShader(void);
		void createAndAttachPrograms(void);
		void deleteShader(void);
		void finalizeShaderUniforms(void);
		void freeCompilerResources(void);
		void reflectShader(void);
		void resetLastProgram(void);
		void ~ShaderOGL();
		void sizeInBytesFromShaderPrimitiveType(mce::ShaderPrimitiveTypes);
		void IsValid(void);
		void ShaderProgram(mce::ShaderType,std::string const&,std::string const&,std::string const&);
		void ~ShaderProgram();
		void ShaderProgramBase(std::string const&,std::string const&,mce::ShaderType);
		void deleteShader(void);
		void getUniformNames(void);
		void ~ShaderProgramOGL();
		void ShaderUniformOGL(std::string const&,int,int,mce::ShaderPrimitiveTypes);
		void bind(bool);
		void ConstantBufferMetaDataManager,void>(void);
		void RenderDevice,void>(void);
		void StencilFaceDescription(void);
		void operator==(mce::StencilFaceDescription const&);
		void createSwapChain(mce::RenderDevice &,mce::SwapChainDescription const&);
		void getMultisampleQualityLevels(std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void isMultisampledSwapChain(void);
		void present(void);
		void releaseSwapChain(void);
		void resizeBuffers(mce::RenderDevice &,uint,uint);
		void SwapChainBase(void);
		void createSwapChain(mce::RenderDevice &,mce::SwapChainDescription const&);
		void getClosestSupportedSampleDescription(mce::SampleDescription);
		void getMultisampleQualityLevels(std::vector<mce::SampleDescription,std::allocator<mce::SampleDescription>> &);
		void getSwapChainDescription(void);
		void isMultisampledSwapChain(void);
		void releaseSwapChain(void);
		void resizeBuffers(uint,uint);
		void createSwapChain(mce::RenderDevice &,mce::SwapChainDescription const&);
		void present(void);
		void releaseSwapChain(void);
		void resizeBuffers(mce::RenderDevice &,uint,uint);
		void Texture(void);
		void bindTexture(mce::RenderContext &,uint,uint);
		void convertToMipmapedTexture(mce::RenderContext &,uint);
		void copyTexture(mce::RenderContext &,mce::Texture*,uint,uint,uint,uint);
		void createTexture(mce::RenderContext &,mce::TextureDescription const&);
		void deleteTexture(void);
		void getDescription(void);
		void isLoaded(void);
		void loadMipMap(mce::RenderContext &,void const*,uint);
		void lock(mce::RenderContext &);
		void operator=(mce::Texture&&);
		void subBuffer(mce::RenderContext &,void const*);
		void subBuffer(mce::RenderContext &,void const*,uint,uint,uint,uint,uint);
		void supportsMipMaps(void);
		void unlock(mce::RenderContext &);
		void ~Texture();
		void _removeIfBound(mce::TextureBase const&);
		void convertToMipmapedTexture(uint);
		void createTexture(mce::TextureDescription const&);
		void deleteTexture(void);
		void getDescription(void);
		void isLoaded(void);
		void ~TextureBase();
		void TextureDescription(void);
		void frameBufferAttachmentTypeFromTextureFormat(mce::TextureFormat);
		void textureFormatToByteStride(mce::TextureFormat);
		void getOpenGLInternalRenderBufferFormatFromTextureFormat(mce::TextureFormat);
		void getOpenGLInternalTextureFormat(mce::TextureFormat);
		void getOpenGLTextureFormatFromTextureFormat(mce::TextureFormat);
		void getOpenGLTextureTargetFromTextureDescription(mce::TextureDescription const&);
		void getOpenGLTextureTypeFromTextureFormat(mce::TextureFormat);
		void TextureOGL(mce::TextureOGL&&);
		void TextureOGL(void);
		void bindTexture(mce::RenderContext &,uint,uint);
		void convertToMipmapedTexture(mce::RenderContext &,uint);
		void copyTexture(mce::RenderContext &,mce::Texture *,uint,uint,uint,uint);
		void createMipMap(mce::RenderContext &,void const*,uint,uint,uint);
		void createTexture(mce::RenderContext &,mce::TextureDescription const&);
		void deleteTexture(void);
		void getTextureName(void);
		void operator=(mce::TextureOGL&&);
		void subBuffer(mce::RenderContext &,void const*);
		void subBuffer(mce::RenderContext &,void const*,uint,uint,uint,uint,uint);
		void supportsMipMaps(void);
		void unlock(mce::RenderContext &);
		void ~TextureOGL();
		void TexturePtr(TextureGroup &,std::string const&);
		void TexturePtr(mce::TexturePtr&&);
		void TexturePtr(void);
		void _deref(void);
		void _move(mce::TexturePtr&&);
		void clone(void);
		void makeTemporaryWrapper(mce::Texture &);
		void onGroupReloaded(void);
		void operator=(mce::TexturePtr&&);
		void ~TexturePtr();
		void fromString(std::string const&);
		void toString(void);
		void UniformMetaData(void);
		void getElementsExtent(void);
		void getUniformPrimitiveSize(void);
		void getUniformSize(void);
		void ~UniformMetaData();
		void VerletIntegrator(void);
		void getChangeInPosition(void);
		void getCurrentPosition(void);
		void getInterpolatedChangeInPosition(void);
		void getInterpolatedPosition(void);
		void getNextTickPosition(void);
		void integrate(mce::TimeStep const&);
		void interpolate(mce::TimeStep const&);
		void setPosition(glm::detail::tvec3<float> const&);
		void setVelocity(glm::detail::tvec3<float> const&);
		void tick(mce::TimeStep const&);
		void VertexFormat(void);
		void enableField(mce::VertexField);
		void getFieldOffset(mce::VertexField,void *);
		void getID(void);
		void getVertexSize(void);
		void hasField(mce::VertexField);
		void operator bool(void);
		void operator!=(mce::VertexFormat const&);
		void operator<(mce::VertexFormat const&);
		void operator==(mce::VertexFormat const&);
		void WeatherConstants(void);
		void init(void);
		void WorldConstants(void);
		void init(void);
		void refreshWorldConstants(void);
		void WorldConstantsHolographic(void);
		void _adjustViewMatsForStereo(Matrix &,Matrix &,Matrix const&);
		void _setConstantsForHolographicDrawing(Matrix const&);
		void _setConstantsForNormalDrawing(Matrix const&);
		void _setConstantsForTextureDrawing(Matrix const&);
		void getLeftShiftMat(void);
		void getMatrixPatch(Matrix &);
		void init(void);
		void refreshWorldConstants(bool);
		void resetViewProjOverride(void);
		void setLeftAndRightShiftMats(Matrix &,Matrix &);
		void setMatrixPatch(Matrix const&);
		void setRenderTextureStereo(bool);
		void setViewProjOverrides(Matrix &,Matrix &,Matrix &,Matrix &);
		void _isMaterialGroup(Json::Value const&);
		void glTargetFromBufferType(mce::BufferType);
		void GL_InvalidateFramebuffer(bool,bool,bool);
		void getProcAddress(char const*);
		void initGLExtension(void);
		void splitString(std::string const&,char);
	}
};
