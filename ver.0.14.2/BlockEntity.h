#pragma once
class BlockEntity{
	public:
		BlockEntity(BlockEntityType,BlockPos const&,std::string const&);
		void _destructionWobble(float &,float &,float &);
		void _resetAABB(void);
		void clearCache(void);
		void distanceToSqr(Vec3 const&);
		void getAABB(void);
		void getCrackEntity(BlockSource &,BlockPos const&);
		void getData(void);
		void getDebugText(std::vector<std::string,std::allocator<std::string>> &);
		void getPosition(void);
		void getRendererId(void);
		void getRunningId(void);
		void getShadowRadius(BlockSource &);
		void getType(void);
		void getUpdatePacket(BlockSource &);
		void initBlockEntities(void);
		void isClientSideOnly(void);
		void isFinished(void);
		void isInWorld(void);
		void isType(BlockEntity&,BlockEntityType);
		void isType(BlockEntityType);
		void load(CompoundTag &);
		void loadStatic(CompoundTag &);
		void onChanged(BlockSource &);
		void onNeighborChanged(BlockSource &,BlockPos const&);
		void onRemoved(void);
		void onUpdatePacket(CompoundTag &);
		void save(CompoundTag &);
		void setBB(AABB);
		void setChanged(void);
		void setClientSideOnly(bool);
		void setData(int);
		void setId(BlockEntityType,std::string const&);
		void setRendererId(BlockEntityRendererId);
		void setRunningId(int);
		void stopDestroy(void);
		void tick(BlockSource &);
		void triggerEvent(int,int);
		void ~BlockEntity();
		void ~BlockEntity();
};
